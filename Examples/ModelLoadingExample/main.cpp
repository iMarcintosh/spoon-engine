#include <SpoonEngine/SpoonEngine.h>
#include <iostream>
#include <fstream>

#ifdef SPOON_PLATFORM_MACOS
    #define GL_SILENCE_DEPRECATION
    #include <OpenGL/gl3.h>
#else
    #include <GL/glew.h>
#endif

class ModelLoadingExampleApp : public SpoonEngine::Application {
public:
    ModelLoadingExampleApp() : Application("SpoonEngine - 3D Model Loading Demo") {
        std::cout << "Model Loading Example created" << std::endl;
    }
    
    virtual ~ModelLoadingExampleApp() {
        std::cout << "Model Loading Example destroyed" << std::endl;
    }
    
protected:
    void OnInitialize() override {
        std::cout << "Model Loading Example initialized" << std::endl;
        
        GetRenderer()->SetClearColor(0.1f, 0.15f, 0.2f, 1.0f);
        
        auto world = GetWorld();
        
        // Register components
        world->RegisterComponent<SpoonEngine::Transform>();
        world->RegisterComponent<SpoonEngine::MeshRenderer>();
        world->RegisterComponent<SpoonEngine::CameraComponent>();
        
        // Register render system
        m_RenderSystem = world->RegisterSystem<SpoonEngine::RenderSystem>();
        m_RenderSystem->SetWorld(world);
        
        SpoonEngine::Signature renderSignature;
        renderSignature.set(world->GetComponentManager()->GetComponentType<SpoonEngine::Transform>());
        renderSignature.set(world->GetComponentManager()->GetComponentType<SpoonEngine::MeshRenderer>());
        world->SetSystemSignature<SpoonEngine::RenderSystem>(renderSignature);
        
        // Create scene with models
        CreateScene();
        
        // Setup camera
        SetupCamera();
        
        std::cout << "Model loading demo initialized with " << m_ModelEntities.size() << " model instances" << std::endl;
    }
    
private:
    void CreateScene() {
        auto world = GetWorld();
        
        // Create a simple procedural OBJ model for demonstration
        CreateProceduralModel();
        
        // Try to load the procedural model
        auto model = SpoonEngine::Model::Create("procedural_cube.obj");
        if (model->Load()) {
            std::cout << "Successfully loaded model with " << model->GetMeshCount() << " meshes" << std::endl;
            
            // Display model information
            auto boundingBox = model->GetBoundingBox();
            auto center = model->GetCenter();
            auto size = model->GetSize();
            
            std::cout << "Model bounding box:" << std::endl;
            std::cout << "  Center: (" << center.x << ", " << center.y << ", " << center.z << ")" << std::endl;
            std::cout << "  Size: (" << size.x << ", " << size.y << ", " << size.z << ")" << std::endl;
            
            // Create multiple instances of the model
            CreateModelInstances(model);
        } else {
            std::cout << "Failed to load model, creating fallback cubes" << std::endl;
            CreateFallbackCubes();
        }
        
        // Create ground plane
        CreateGroundPlane();
    }
    
    void CreateProceduralModel() {
        // Create a simple OBJ file for demonstration
        std::ofstream objFile("procedural_cube.obj");
        if (objFile.is_open()) {
            objFile << "# Procedural Cube Model for SpoonEngine Demo\n";
            objFile << "# Generated by ModelLoadingExample\n\n";
            
            // Vertices (positions)
            objFile << "v -1.0 -1.0 -1.0\n";  // 0
            objFile << "v  1.0 -1.0 -1.0\n";  // 1
            objFile << "v  1.0  1.0 -1.0\n";  // 2
            objFile << "v -1.0  1.0 -1.0\n";  // 3
            objFile << "v -1.0 -1.0  1.0\n";  // 4
            objFile << "v  1.0 -1.0  1.0\n";  // 5
            objFile << "v  1.0  1.0  1.0\n";  // 6
            objFile << "v -1.0  1.0  1.0\n";  // 7
            objFile << "\n";
            
            // Texture coordinates
            objFile << "vt 0.0 0.0\n";
            objFile << "vt 1.0 0.0\n";
            objFile << "vt 1.0 1.0\n";
            objFile << "vt 0.0 1.0\n";
            objFile << "\n";
            
            // Normals
            objFile << "vn  0.0  0.0 -1.0\n";  // Front
            objFile << "vn  0.0  0.0  1.0\n";  // Back
            objFile << "vn -1.0  0.0  0.0\n";  // Left
            objFile << "vn  1.0  0.0  0.0\n";  // Right
            objFile << "vn  0.0 -1.0  0.0\n";  // Bottom
            objFile << "vn  0.0  1.0  0.0\n";  // Top
            objFile << "\n";
            
            // Faces (using vertex/texture/normal indices)
            // Front face
            objFile << "f 1/1/1 2/2/1 3/3/1\n";
            objFile << "f 1/1/1 3/3/1 4/4/1\n";
            
            // Back face
            objFile << "f 5/1/2 7/3/2 6/2/2\n";
            objFile << "f 5/1/2 8/4/2 7/3/2\n";
            
            // Left face
            objFile << "f 1/1/3 4/4/3 8/3/3\n";
            objFile << "f 1/1/3 8/3/3 5/2/3\n";
            
            // Right face
            objFile << "f 2/1/4 6/2/4 7/3/4\n";
            objFile << "f 2/1/4 7/3/4 3/4/4\n";
            
            // Bottom face
            objFile << "f 1/1/5 5/2/5 6/3/5\n";
            objFile << "f 1/1/5 6/3/5 2/4/5\n";
            
            // Top face
            objFile << "f 4/1/6 3/2/6 7/3/6\n";
            objFile << "f 4/1/6 7/3/6 8/4/6\n";
            
            objFile.close();
            std::cout << "Created procedural cube model: procedural_cube.obj" << std::endl;
        } else {
            std::cout << "Failed to create procedural model file" << std::endl;
        }
    }
    
    void CreateModelInstances(std::shared_ptr<SpoonEngine::Model> model) {
        auto world = GetWorld();
        
        // Create multiple instances of the loaded model
        std::vector<SpoonEngine::Vector3> positions = {
            SpoonEngine::Vector3(-3.0f, 1.0f, -2.0f),
            SpoonEngine::Vector3(0.0f, 1.0f, -2.0f),
            SpoonEngine::Vector3(3.0f, 1.0f, -2.0f),
            SpoonEngine::Vector3(-1.5f, 1.0f, 1.0f),
            SpoonEngine::Vector3(1.5f, 1.0f, 1.0f)
        };
        
        for (size_t i = 0; i < positions.size(); i++) {
            // For each mesh in the model, create an entity
            for (size_t meshIndex = 0; meshIndex < model->GetMeshCount(); meshIndex++) {
                auto entity = world->CreateEntity();
                
                SpoonEngine::Transform transform;
                transform.Position = positions[i];
                transform.Position.y += meshIndex * 0.1f; // Slight offset for multi-mesh models
                transform.Scale = SpoonEngine::Vector3(0.8f, 0.8f, 0.8f);
                transform.Rotation = SpoonEngine::Vector3(0.0f, i * 45.0f, 0.0f);
                world->AddComponent(entity, transform);
                
                const auto& modelMesh = model->GetMesh(meshIndex);
                
                SpoonEngine::MeshRenderer renderer;
                renderer.Mesh = modelMesh.MeshData;
                renderer.Material = modelMesh.Material;
                
                // Update material lighting properties
                if (renderer.Material) {
                    renderer.Material->SetFloat3("u_LightPosition", glm::vec3(5.0f, 8.0f, 5.0f));
                    renderer.Material->SetFloat3("u_LightColor", glm::vec3(1.0f, 1.0f, 0.9f));
                }
                
                world->AddComponent(entity, renderer);
                m_ModelEntities.push_back(entity);
                
                std::cout << "Created model instance " << i << ", mesh " << meshIndex 
                          << " (" << modelMesh.Name << ")" << std::endl;
            }
        }
    }
    
    void CreateFallbackCubes() {
        auto world = GetWorld();
        auto mesh = SpoonEngine::Mesh::CreateCube();
        
        // Create basic material shader
        std::string vertexShader = R"(
            #version 330 core
            layout (location = 0) in vec3 a_Position;
            layout (location = 1) in vec3 a_Normal;
            layout (location = 2) in vec2 a_TexCoord;
            
            uniform mat4 u_Model;
            uniform mat4 u_View;
            uniform mat4 u_Projection;
            
            out vec3 v_WorldPos;
            out vec3 v_Normal;
            out vec2 v_TexCoord;
            
            void main() {
                v_WorldPos = vec3(u_Model * vec4(a_Position, 1.0));
                v_Normal = mat3(transpose(inverse(u_Model))) * a_Normal;
                v_TexCoord = a_TexCoord;
                
                gl_Position = u_Projection * u_View * vec4(v_WorldPos, 1.0);
            }
        )";
        
        std::string fragmentShader = R"(
            #version 330 core
            
            in vec3 v_WorldPos;
            in vec3 v_Normal;
            in vec2 v_TexCoord;
            
            uniform vec3 u_Color;
            uniform vec3 u_LightPosition;
            uniform vec3 u_LightColor;
            uniform vec3 u_CameraPosition;
            
            out vec4 FragColor;
            
            void main() {
                vec3 norm = normalize(v_Normal);
                vec3 lightDir = normalize(u_LightPosition - v_WorldPos);
                
                // Ambient
                float ambientStrength = 0.1;
                vec3 ambient = ambientStrength * u_LightColor;
                
                // Diffuse
                float diff = max(dot(norm, lightDir), 0.0);
                vec3 diffuse = diff * u_LightColor;
                
                // Specular
                vec3 viewDir = normalize(u_CameraPosition - v_WorldPos);
                vec3 reflectDir = reflect(-lightDir, norm);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 specular = spec * u_LightColor;
                
                vec3 result = (ambient + diffuse + specular) * u_Color;
                FragColor = vec4(result, 1.0);
            }
        )";
        
        auto shader = SpoonEngine::Shader::Create("FallbackShader", vertexShader, fragmentShader);
        
        std::vector<SpoonEngine::Vector3> positions = {
            SpoonEngine::Vector3(-2.0f, 1.0f, 0.0f),
            SpoonEngine::Vector3(0.0f, 1.0f, 0.0f),
            SpoonEngine::Vector3(2.0f, 1.0f, 0.0f)
        };
        
        for (size_t i = 0; i < positions.size(); i++) {
            auto entity = world->CreateEntity();
            
            SpoonEngine::Transform transform;
            transform.Position = positions[i];
            transform.Scale = SpoonEngine::Vector3(0.8f, 0.8f, 0.8f);
            world->AddComponent(entity, transform);
            
            auto material = SpoonEngine::Material::Create(shader, "FallbackMaterial" + std::to_string(i));
            material->SetFloat3("u_Color", glm::vec3(0.6f + i * 0.2f, 0.4f, 0.8f - i * 0.2f));
            material->SetFloat3("u_LightPosition", glm::vec3(5.0f, 8.0f, 5.0f));
            material->SetFloat3("u_LightColor", glm::vec3(1.0f, 1.0f, 0.9f));
            
            SpoonEngine::MeshRenderer renderer;
            renderer.Mesh = mesh;
            renderer.Material = material;
            world->AddComponent(entity, renderer);
            
            m_ModelEntities.push_back(entity);
        }
    }
    
    void CreateGroundPlane() {
        auto world = GetWorld();
        auto mesh = SpoonEngine::Mesh::CreateCube();
        
        auto entity = world->CreateEntity();
        SpoonEngine::Transform transform;
        transform.Position = SpoonEngine::Vector3(0.0f, -1.0f, 0.0f);
        transform.Scale = SpoonEngine::Vector3(12.0f, 0.1f, 12.0f);
        world->AddComponent(entity, transform);
        
        // Create ground material
        std::string vertexShader = R"(
            #version 330 core
            layout (location = 0) in vec3 a_Position;
            layout (location = 1) in vec3 a_Normal;
            layout (location = 2) in vec2 a_TexCoord;
            
            uniform mat4 u_Model;
            uniform mat4 u_View;
            uniform mat4 u_Projection;
            
            out vec3 v_Normal;
            out vec2 v_TexCoord;
            
            void main() {
                v_Normal = mat3(transpose(inverse(u_Model))) * a_Normal;
                v_TexCoord = a_TexCoord * 6.0; // Tile the texture
                
                gl_Position = u_Projection * u_View * u_Model * vec4(a_Position, 1.0);
            }
        )";
        
        std::string fragmentShader = R"(
            #version 330 core
            
            in vec3 v_Normal;
            in vec2 v_TexCoord;
            
            out vec4 FragColor;
            
            void main() {
                // Create a simple grid pattern
                vec2 grid = abs(fract(v_TexCoord) - 0.5);
                float line = smoothstep(0.0, 0.1, grid.x) * smoothstep(0.0, 0.1, grid.y);
                
                vec3 color = mix(vec3(0.3, 0.3, 0.4), vec3(0.5, 0.5, 0.6), line);
                FragColor = vec4(color, 1.0);
            }
        )";
        
        auto shader = SpoonEngine::Shader::Create("GroundShader", vertexShader, fragmentShader);
        auto material = SpoonEngine::Material::Create(shader, "GroundMaterial");
        
        SpoonEngine::MeshRenderer renderer;
        renderer.Mesh = mesh;
        renderer.Material = material;
        world->AddComponent(entity, renderer);
    }
    
    void SetupCamera() {
        auto world = GetWorld();
        
        // Create camera
        auto cameraEntity = world->CreateEntity();
        SpoonEngine::Transform cameraTransform;
        cameraTransform.Position = SpoonEngine::Vector3(8, 6, 8);
        world->AddComponent(cameraEntity, cameraTransform);
        
        SpoonEngine::CameraComponent cameraComp;
        cameraComp.Camera = std::make_shared<SpoonEngine::FlyCamera>();
        cameraComp.Camera->SetPerspective(45.0f, 1280.0f / 720.0f, 0.1f, 100.0f);
        cameraComp.IsActive = true;
        cameraComp.Priority = 0;
        world->AddComponent(cameraEntity, cameraComp);
        
        m_CameraEntity = cameraEntity;
        m_RenderSystem->SetCamera(cameraComp.Camera);
    }
    
public:
    void OnUpdate(float deltaTime) override {
        if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::Escape)) {
            Shutdown();
        }
        
        auto world = GetWorld();
        
        // Rotate models
        for (auto entity : m_ModelEntities) {
            if (world->HasComponent<SpoonEngine::Transform>(entity)) {
                auto& transform = world->GetComponent<SpoonEngine::Transform>(entity);
                transform.Rotation.y += deltaTime * 20.0f;
            }
        }
        
        // Handle camera movement
        auto& cameraComp = world->GetComponent<SpoonEngine::CameraComponent>(m_CameraEntity);
        auto flyCamera = std::dynamic_pointer_cast<SpoonEngine::FlyCamera>(cameraComp.Camera);
        
        if (flyCamera) {
            if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::W)) {
                flyCamera->ProcessKeyboard(static_cast<int>(SpoonEngine::KeyCode::W), deltaTime);
            }
            if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::S)) {
                flyCamera->ProcessKeyboard(static_cast<int>(SpoonEngine::KeyCode::S), deltaTime);
            }
            if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::A)) {
                flyCamera->ProcessKeyboard(static_cast<int>(SpoonEngine::KeyCode::A), deltaTime);
            }
            if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::D)) {
                flyCamera->ProcessKeyboard(static_cast<int>(SpoonEngine::KeyCode::D), deltaTime);
            }
            if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::Q)) {
                flyCamera->ProcessKeyboard(static_cast<int>(SpoonEngine::KeyCode::Q), deltaTime);
            }
            if (SpoonEngine::Input::IsKeyPressed(SpoonEngine::KeyCode::E)) {
                flyCamera->ProcessKeyboard(static_cast<int>(SpoonEngine::KeyCode::E), deltaTime);
            }
        }
        
        // Update camera position in materials
        for (auto entity : m_ModelEntities) {
            if (world->HasComponent<SpoonEngine::MeshRenderer>(entity)) {
                auto& meshRenderer = world->GetComponent<SpoonEngine::MeshRenderer>(entity);
                if (meshRenderer.Material) {
                    meshRenderer.Material->SetFloat3("u_CameraPosition", 
                        glm::vec3(cameraComp.Camera->GetPosition().x,
                                 cameraComp.Camera->GetPosition().y,
                                 cameraComp.Camera->GetPosition().z));
                }
            }
        }
    }
    
    void OnRender() override {
        // Rendering handled by render system
        m_RenderSystem->Render(GetRenderer());
    }
    
    void OnShutdown() override {
        std::cout << "Model Loading Example shutdown" << std::endl;
    }
    
private:
    std::shared_ptr<SpoonEngine::RenderSystem> m_RenderSystem;
    std::vector<SpoonEngine::Entity> m_ModelEntities;
    SpoonEngine::Entity m_CameraEntity;
};

SPOON_MAIN(ModelLoadingExampleApp)